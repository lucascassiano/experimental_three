'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _reactSizeme = require('react-sizeme');

var _reactSizeme2 = _interopRequireDefault(_reactSizeme);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

//import OBJLoader from 'three-react-obj-loader';

var OrbitControls = require('react-cubeview/lib/OrbitControls')(THREE);

var renderer = void 0,
    scene = void 0,
    camera = void 0,
    mainSphere = void 0,
    windowSize = { width: 0, height: 0 },
    animation = void 0,
    controls = void 0;

var Container3d = function (_Component) {
  _inherits(Container3d, _Component);

  function Container3d(props) {
    _classCallCheck(this, Container3d);

    return _possibleConstructorReturn(this, (Container3d.__proto__ || Object.getPrototypeOf(Container3d)).call(this, props));
  }

  _createClass(Container3d, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.init();
      this.updateDimensions();
      window.addEventListener("resize", this.updateDimensions.bind(this));
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      renderer = null;
      scene = null;
      camera = null;
      window.removeEventListener("resize", this.updateDimensions.bind(this));
    }

    /**
     * Defines the angles - useful when using OrbitControls from react-cubeview
     * @param {*} phi 
     * @param {*} theta 
     */

  }, {
    key: 'setAngles',
    value: function setAngles(phi, theta) {
      controls.setPolarAngle(phi);
      controls.setAzimuthalAngle(theta);
    }
  }, {
    key: 'getSize',
    value: function getSize() {
      var _props = this.props,
          width = _props.width,
          percentageWidth = _props.percentageWidth,
          aspect = _props.aspect;

      if (percentageWidth) width = window.innerWidth * parseFloat(percentageWidth) / 100;

      var height = width / aspect;

      height = 200;
      console.log("size", width, height);
      return { width: width, height: height };
    }
  }, {
    key: 'updateDimensions',
    value: function updateDimensions() {
      //Get the proportions from screen

      var _props2 = this.props,
          width = _props2.width,
          percentageWidth = _props2.percentageWidth,
          aspect = _props2.aspect,
          fitScreen = _props2.fitScreen,
          marginLeft = _props2.marginLeft,
          marginTop = _props2.marginTop,
          marginBottom = _props2.marginBottom,
          height = _props2.height;


      if (percentageWidth) {
        width = parseInt(window.innerWidth * parseInt(percentageWidth) / 100.0);
      }

      if (aspect) {
        height = width / aspect;
      }

      if (fitScreen) {
        height = window.innerHeight;
        if (marginTop) {
          height = height - marginTop;
        }

        if (marginBottom) {
          height = height - marginBottom;
        }
      }

      var canvas = this.refs.threeCanvas;

      canvas.height = height;
      renderer.setSize(width, height);
      camera.aspect = width / height;

      camera.updateProjectionMatrix();
    }
  }, {
    key: 'init',
    value: function init() {
      var _getSize = this.getSize(),
          width = _getSize.width,
          height = _getSize.height;

      var canvas = this.refs.threeCanvas;
      canvas.height = height;
      var marginTop = this.props.marginTop;

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
      camera.position.set(0, 20, 20);
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });

      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      this._createScene(canvas);
      var _this = this;

      this._render = function () {
        animation = requestAnimationFrame(_this._render);

        var _this$props = _this.props,
            phi = _this$props.phi,
            theta = _this$props.theta;


        if (phi && theta && controls) {
          controls.setPolarAngle(phi);
          controls.setAzimuthalAngle(theta);
        }

        if (_this.props.update) {
          _this.props.update(scene, camera, renderer);
        }

        renderer.render(scene, camera);
        // this.updateRendererDimensions();
      };

      this._render();
    }
  }, {
    key: 'setAngles',
    value: function setAngles(phi, theta) {
      //console.log(phi, theta);
      controls.setPolarAngle(phi);
      controls.setAzimuthalAngle(theta);
    }
  }, {
    key: 'reloadScene',
    value: function reloadScene(newScene) {
      if (newScene) scene = newScene;else scene = new THREE.Scene();

      var _props3 = this.props,
          addControls = _props3.addControls,
          addGrid = _props3.addGrid,
          addLight = _props3.addLight,
          enableZoom = _props3.enableZoom,
          enableKeys = _props3.enableKeys,
          enablePan = _props3.enablePan;


      if (addGrid != undefined ? addGrid : true) {
        var gridXZ = new THREE.GridHelper(20, 20);
        gridXZ.name = "grid";
        scene.add(gridXZ);

        var planeGeometry = new THREE.PlaneGeometry(20, 20);
        planeGeometry.rotateX(-Math.PI / 2);
        var planeMaterial = new THREE.ShadowMaterial({ opacity: 0.4 });
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;
        scene.add(plane);
      }

      if (addLight != undefined ? addLight : true) {
        scene.add(new THREE.AmbientLight(0xf0f0f0));
        var light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(50, 50, 50);
        light.castShadow = true;
        light.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(70, 1, 10, 1000));
        light.shadow.bias = -0.000222;
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        scene.add(light);
      }
      
      if (this.props.setup) {
        this.props.setup(scene, camera, renderer);
      }
      //this.updateDimensions();
    }

    //Insert all 3D elements here

  }, {
    key: '_createScene',
    value: function _createScene(canvas) {
      console.log(this.props);

      var _props4 = this.props,
          addControls = _props4.addControls,
          addGrid = _props4.addGrid,
          addLight = _props4.addLight,
          enableZoom = _props4.enableZoom,
          enableKeys = _props4.enableKeys,
          enablePan = _props4.enablePan;


      if (addGrid != undefined ? addGrid : true) {
        var gridXZ = new THREE.GridHelper(20, 20);
        gridXZ.name = "grid";
        scene.add(gridXZ);

        var planeGeometry = new THREE.PlaneGeometry(20, 20);
        planeGeometry.rotateX(-Math.PI / 2);
        var planeMaterial = new THREE.ShadowMaterial({ opacity: 0.4 });
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;
        scene.add(plane);
      }

      if (addControls != undefined ? addControls : true) {
        controls = new OrbitControls(camera, canvas);
        controls.enablePan = enablePan != undefined ? enablePan : true;
        controls.enableZoom = enableZoom != undefined ? enableZoom : true;
        controls.enableKeys = enableKeys != undefined ? enableKeys : true;
      }

      if (addLight != undefined ? addLight : true) {
        scene.add(new THREE.AmbientLight(0xf0f0f0));
        var light = new THREE.SpotLight(0xffffff, 1.5);
        light.position.set(50, 50, 50);
        light.castShadow = true;
        light.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(70, 1, 10, 1000));
        light.shadow.bias = -0.000222;
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;
        scene.add(light);
      }

      var _this = this;

      if (this.props.setup) {
        this.props.setup(scene, camera, renderer);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement('canvas', { ref: 'threeCanvas' })
      );
    }
  }]);

  return Container3d;
}(_react.Component);

exports.default = Container3d;